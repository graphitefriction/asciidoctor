= Register Extensions

== Register one or more extensions

These extensions are registered per document using a callback that feels like a DSL:

```ruby
Asciidoctor::Extensions.register do |document|
  preprocessor FrontMatterPreprocessor
  tree_processor ShellSessionTreeProcessor
  postprocessor CopyrightFooterPostprocessor
  docinfo_processor TrackingCodeDocinfoProcessor if document.basebackend? 'html'
  block ShoutBlock
  block_macro GistBlockMacro if document.basebackend? 'html'
  inline_macro ManInlineMacro
  include_processor UriIncludeProcessor
end
```

CAUTION: Extension classes must be defined outside of the register block.
Once an extension class is registered, it is frozen, preventing further modification.
If you define an extension class inside the register block, it will result in an error on subsequent invocations.

You can register more than one processor of each type, though you can only have one processor per custom block or macro.
Each registered class is instantiated when the [.class]#Asciidoctor::Document# is created.

NOTE: There is currently no extension point for processing a built-in block, such as a normal paragraph.
Look for that feature in a future Asciidoctor release.

////
See if this warning is still necessary:

WARNING: The extension API in Asciidoctor is stable with the exception of inline macros.
Since inline content is not parsed until the convert phase, the inline macro processor must return converted text (e.g., HTML) rather than an AST node.
Once Asciidoctor is changed to https://github.com/asciidoctor/asciidoctor/issues/61[process inline content during the parse phase^], the inline macro processor will need to return an inline node.
When that switch occurs, there will either be some sort of adapter or required migration for inline macro processors, but that has yet to be determined.

However, the way extensions are implemented in AsciiDoc Python presents a number of problems:

* They are challenging to write because they work at such a low-level (read as: nasty regular expressions).
* They are fragile since they often rely on system commands to do anything significant.
* They are hard to distribute due to the lack of integration with a formal distribution system.

For now, you need to use the Asciidoctor API (not the CLI) in order to register the extensions and invoke Asciidoctor.
Eventually, we'll be able to load extensions packaged in a RubyGem (Ruby) or JAR (Java) by scanning
the LOAD_PATH (Ruby) or classpath (Java), respectively.
We may also ship some built-in extensions that can be enabled using an attribute named `extensions`, similar to how Markdown processors work.

TIP: For those of you on the JVM, yes, you can write extensions in Java.
We've prototyped it and it works.
We're still sorting out a few technical challenges and documentation to make it completely smooth, but we'll get there.
For details, follow the discussion in issue {issue-ref}/79[#79].
////
